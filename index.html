<!DOCTYPE html>
<html lang="en">

<head>
  <title>Denzel</title>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=0.5">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="Let's help you to know more about me">
  <meta name="keywords" content="Denzel, about me, programmer, draculaas, Github">
  <meta name="author" content="Denzel">
  <link rel="stylesheet" href="assets/css/main.css">
  <link rel="stylesheet" href="assets/css/main2.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Marvel">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
  <link rel="draculaas" icon" type="png" href="assets/img/me.png">
</head>

<body>
  <div class="device-notification">
    <a class="device-notification--logo" href="">
      <img src="assets/img/logo.png" alt="Denzel" width="30" height="30">
      <p>Denis</p>
    </a>
    <p class="device-notification--message">Denzel has so much to offer that we must request you turn on rotation mode
      or find a larger screen. You won't be disappointed.</p>
  </div>
  <div class="perspective effect-rotate-left">
    <div class="container">
      <div class="outer-nav--return"></div>
      <div id="viewport" class="l-viewport">
        <div class="l-wrapper">
          <header class="header">
            <button class="header--cta cta">My Projects</button>
            <div class="header--nav-toggle">
              <span></span>
            </div>
          </header>
          <nav class="l-side-nav">
            <ul class="side-nav">
              <li class="is-active"><span>Home</span></li>
              <li><span>About Me</span></li>
              <li><span>Challenge</span></li>
              <li><span>Contact</span></li>
              <li><span>Projects</span></li>
            </ul>
          </nav>
          <ul class="l-main-content main-content">
            <li class="l-section section section--is-active">
              <div class="intro">
                <div class="intro--banner">
                  <h1>
                    <div>
                      <span id="L">H</span>
                      <span id="I">i</span>
                      <span id="G">,</span>
                      <span id="H">I</span>
                      <span id="H">'</span>
                      <span id="T">m</span>
                    </div>
                  </h1>
                  <div class="element-to-resize">
                    <div class="content">
                      <h2>Denzel</h2>
                      <h2>Denzel</h2>
                    </div>
                  </div>
                  <button1 class="cta"><button class="btn-21">
                      <span>My Projects</span>
                    </button>
                  </button1>
                  <img src="assets/img/draculaas.png" alt="Welcome">
                </div>
                <div class="intro--options">
                  <ul id="circleSocial">
                    <li><a href="https://github.com/draculaas"><span></span><span></span><span></span><span></span><span
                          class="fab fa-github"></span></a></li>
                    <li><a href="https://t.me/f_disk_you"><span></span><span></span><span></span><span></span><span
                          class="fab fa-telegram"></span></a></li>
                  </ul>
                </div>
              </div>
            </li>
            <li class="l-section section">
              <main>
                <canvas class="plane-canvas" id="plane-canvas"></canvas>
                <canvas class="main-canvas" id="main-canvas"></canvas>
                <div class="mouse" id="mouse">Hold mouse1 button</div>
                <div class="plate">
                  <h2 class="text-animation" data-js="text">SWE with 8 years of experience specializing in the
                    development of distributed systems</h2>
                  <p class="text-animation" data-js="text">Follow me</p>
                </div>
                <div class='music-card playing'>
                  <div class='image'></div>
                  <div class='wave'></div>
                  <div class='wave'></div>
                  <div class='wave'></div>
                  <div class='info'>
                    <h2 class='title'>Je te laisserai des mots</h2>
                    <div class='artist'>Listen With Me</div>
                  </div>
                  <i class="fa fa-pause trigger" aria-hidden="true"></i>
                  <i class="fa fa-play trigger" aria-hidden="true"></i>
                </div>
              </main>
              <div class="text"></div>
            </li>

            <li class="l-section section">
              <div class="form-desktop">
                <div id="container">
                  <div id="game"></div>
                  <div id="score">0</div>
                  <div id="instructions">Click (or press the spacebar) to place the block</div>
                  <div class="game-over">
                    <h2>Game Over</h2>
                    <p>You did great, you're the best.</p>
                    <p>Click or spacebar to start again</p>
                  </div>
                  <div class="game-ready">
                    <div id="start-button">Start</div>
                    <div></div>
                  </div>
                </div>
              </div>
            </li>

            <li class="l-section section">
              <div class="card-container">
                <div class="card nitro-card">
                  <div class="card-header">
                    <div style="background-color: #b6b6bf;" class="banner-img"></div>
                  </div>
                  <div class="card-body">
                    <div class="profile-header">
                      <div class="profil-logo">
                        <img src="./assets/img/me.png" />
                      </div>
                    </div>
                    <div class="profile-body">
                      <div class="username">
                        <a> Denzel </a>
                      </div>
                      <p>your adv could be placed here =)</p>
                      <hr />
                      <a href="https://github.com/draculaas" target="_blank" class="btn">Visit My Github</a>
                      <div class="basic-infos">
                        <div class="category-title">About Me</div>
                        <p>
                          SWE with 8 years of experience specializing in distributed systems,<br> since &rarr; Mar 1,
                          2016
                        </p>
                      </div>
                      <div class="roles">
                        <div class="category-title">Skills</div>
                        <div class="roles-list">
                          <div class="role">
                            <div class="role-color" style="background: lightyellow"></div>
                            <p>Golang</p>
                          </div>
                          <div class="role">
                            <div class="role-color" style="background: darkred"></div>
                            <p>Python</p>
                          </div>
                          <div class="role">
                            <div class="role-color" style="background: darkgreen"></div>
                            <p>JavaScript</p>
                          </div>
                          <div class="role">
                            <div class="role-color" style="background: yellow"></div>
                            <p>TypeScript</p>
                          </div>
                          <div class="role">
                            <div class="role-color" style="background: darkblue"></div>
                            <p>Raft</p>
                          </div>
                          <div class="role">
                            <div class="role-color" style="background: darkblue"></div>
                            <p>Kubernetes</p>
                          </div>
                          <div class="role">
                            <div class="role-color" style="background: orange"></div>
                            <p>Docker</p>
                          </div>
                          <div class="role">
                            <div class="role-color" style="background: rgb(137, 124, 98)"></div>
                            <p>React.JS</p>
                          </div>
                          <div class="role role-add">
                            <div class="role-add-text">+</div>
                          </div>
                        </div>
                      </div>
                      <!-- <div class="note">
                        <div class="category-title">Note</div>
                        <textarea placeholder="Click for add a note">I know who you are, when send me messege... leopolnow@gmail.com</textarea>
                      </div> -->
                      <!-- <div class="message">
                        <input id="content" type="text" placeholder="Send a message to @Denzel" />
                      </div> -->
                      <!-- <div id="message-status" style="display: none;"><b>Message Sent!</b></div> -->
                    </div>
                  </div>
                </div>
              </div>
            </li>

            <li class="l-section section">
              <div class="work">
                <h2>My Projects</h2>
                <div class="work--lockup">
                  <ul class="slider">
                    <li class="slider--item slider--item-left">
                      <a href="https://github.com/draculaas/shrek" target="_blank">
                        <div class="slider--item-image">
                          <img src="assets/img/shrek.jpeg"
                            alt="lightweight, distributed relational database built on SQLite">
                        </div>
                        <p class="slider--item-title">Shrek</p>
                        <p class="slider--item-description">Simple distributed relational database built with SQLite
                          using the Raft consensus algorithm</p>
                      </a>
                    </li>
                    <li class="slider--item slider--item-center">
                      <a href="https://github.com/FAQGURU/FAQGURU" target="_blank">
                        <div class="slider--item-image">
                          <img src="assets/img/faq.png" alt="FAQGURU">
                        </div>
                        <p class="slider--item-title">FAQGURU</p>
                        <p class="slider--item-description">
                          A collection of super-popular Interview questions along with answers, and some code-snippets
                        </p>
                      </a>
                    </li>
                    <li class="slider--item slider--item-right">
                      <a href="https://github.com/draculaas/go-practice" target="_blank">
                        <div class="slider--item-image">
                          <img src="assets/img/go.png" alt="valinfo">
                        </div>
                        <p class="slider--item-title">GO practice</p>
                        <p class="slider--item-description">A collection of questions and notes regarding the Go
                          programming language</p>
                      </a>
                    </li>
                  </ul>
                  <div class="slider--prev">
                    <img src="assets/img/next-arrow-image.png" alt="Previous" />
                  </div>
                  <div class="slider--next">
                    <img src="assets/img/previous-arrow-image.png" alt="Previous" />
                  </div>
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <ul class="outer-nav">
      <li class="is-active">Home</li>
      <li>About Me</li>
      <li>Challenge</li>
      <li>Contact</li>
      <li>Projects</li>
    </ul>
  </div>
  <script src="assets/js/index.js"></script>
  <script src="https://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenMax.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="assets/js/vendor/jquery-2.2.4.min.js"><\/script>')</script>
  <script src="assets/js/functions-min.js"></script>
  <script>
    const tipButtons = document.querySelectorAll('.tip-button')

    tipButtons.forEach((button) => {
      let coin = button.querySelector('.coin')

      coin.maxMoveLoopCount = 90

      button.addEventListener('click', () => {
        if (button.clicked) return
        button.classList.add('clicked')
        setTimeout(() => {
          coin.sideRotationCount = Math.floor(Math.random() * 5) * 90
          coin.maxFlipAngle = (Math.floor(Math.random() * 4) + 3) * Math.PI
          button.clicked = true
          flipCoin()
        }, 50)
      })

      const flipCoin = () => {
        coin.moveLoopCount = 0
        flipCoinLoop()
      }

      const resetCoin = () => {
        coin.style.setProperty('--coin-x-multiplier', 0)
        coin.style.setProperty('--coin-scale-multiplier', 0)
        coin.style.setProperty('--coin-rotation-multiplier', 0)
        coin.style.setProperty('--shine-opacity-multiplier', 0.4)
        coin.style.setProperty('--shine-bg-multiplier', '50%')
        coin.style.setProperty('opacity', 1)

        setTimeout(() => {
          button.clicked = false
        }, 300)
      }

      const flipCoinLoop = () => {
        coin.moveLoopCount++
        let percentageCompleted = coin.moveLoopCount / coin.maxMoveLoopCount
        coin.angle = -coin.maxFlipAngle * Math.pow((percentageCompleted - 1), 2) + coin.maxFlipAngle

        coin.style.setProperty('--coin-y-multiplier', -11 * Math.pow(percentageCompleted * 2 - 1, 4) + 11)
        coin.style.setProperty('--coin-x-multiplier', percentageCompleted)
        coin.style.setProperty('--coin-scale-multiplier', percentageCompleted * 0.6)
        coin.style.setProperty('--coin-rotation-multiplier', percentageCompleted * coin.sideRotationCount)

        coin.style.setProperty('--front-scale-multiplier', Math.max(Math.cos(coin.angle), 0))
        coin.style.setProperty('--front-y-multiplier', Math.sin(coin.angle))

        coin.style.setProperty('--middle-scale-multiplier', Math.abs(Math.cos(coin.angle), 0))
        coin.style.setProperty('--middle-y-multiplier', Math.cos((coin.angle + Math.PI / 2) % Math.PI))

        coin.style.setProperty('--back-scale-multiplier', Math.max(Math.cos(coin.angle - Math.PI), 0))
        coin.style.setProperty('--back-y-multiplier', Math.sin(coin.angle - Math.PI))

        coin.style.setProperty('--shine-opacity-multiplier', 4 * Math.sin((coin.angle + Math.PI / 2) % Math.PI) - 3.2)
        coin.style.setProperty('--shine-bg-multiplier', -40 * (Math.cos((coin.angle + Math.PI / 2) % Math.PI) - 0.5) + '%')


        if (coin.moveLoopCount < coin.maxMoveLoopCount) {
          if (coin.moveLoopCount === coin.maxMoveLoopCount - 6) button.classList.add('shrink-landing')
          window.requestAnimationFrame(flipCoinLoop)
        } else {
          button.classList.add('coin-landed')
          coin.style.setProperty('opacity', 0)
          setTimeout(() => {
            button.classList.remove('clicked', 'shrink-landing', 'coin-landed')
            setTimeout(() => {
              resetCoin()
            }, 300)
          }, 1500)
        }
      }
    })
  </script>
  <script>
    if (!CSS.supports('d', 'path("")')) {
      $('.switch.smiley').each(function (e) {
        const self = $(this);
        const input = self.children('input');
        self.find('svg path:last-child')[0].setAttribute('d', ((input.is(':checked')) ? 'M3,10.6 C4.66666667,11.8 6.33333333,12.4 8,12.4 C9.66666667,12.4 11.3333333,11.8 13,10.6' : 'M3,12.6 C4.66666667,11.1333333 6.33333333,10.4 8,10.4 C9.66666667,10.4 11.3333333,11.1333333 13,12.6'));
        input.change(function (e) {
          self.find('svg path:last-child')[0].setAttribute('d', ((input.is(':checked')) ? 'M3,10.6 C4.66666667,11.8 6.33333333,12.4 8,12.4 C9.66666667,12.4 11.3333333,11.8 13,10.6' : 'M3,12.6 C4.66666667,11.1333333 6.33333333,10.4 8,10.4 C9.66666667,10.4 11.3333333,11.1333333 13,12.6'));
        });
      });
    }
    document.addEventListener("DOMContentLoaded", function () {
      const audioPlayer = document.getElementById("audio-player");
      const toggleSwitch = document.querySelector(".smiley input");

      toggleSwitch.addEventListener("change", function () {
        if (this.checked) {
          audioPlayer.play();
        } else {
          audioPlayer.pause();
        }
      });
    });
  </script>

  <script>
    const tools = {
      drawPath(ctx, fn) {
        ctx.save();
        ctx.beginPath();
        fn();
        ctx.closePath();
        ctx.restore();
      },
      random(min, max, int) {
        let result = min + Math.random() * (max + (int ? 1 : 0) - min);
        return int ? parseInt(result) : result;
      },
      getVectorLength(p1, p2) {
        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
      },
      easing(t, b, c, d, s) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
      },
      cellEasing(t, b, c, d, s) {
        return c * (t /= d) * t * t * t + b;
      }
    };


    const doc = {
      height: 0,
      width: 0
    };


    const plane = {
      xCell: 0,
      yCell: 0,
      cells: []
    };


    const context = {
      plane: null,
      main: null
    };


    const mouse = {
      x: 0,
      y: 0,
      coords: {
        x: 0,
        y: 0
      },

      down: {
        state: false,
        x: 0,
        y: 0
      }
    };



    const cfg = {
      cell: 35,
      sectionWidth: 8,
      sectionHeight: 1,
      numberOffset: 5,
      shadowBlur: true,
      bgColor: '#181818'
    };


    const ui = {
      plane: '#plane-canvas',
      main: '#main-canvas',
      textNodes: '[data-js=text]',
      mouse: '#mouse'
    };


    class App {
      constructor() {
        this.state = {
          area: 0,
          time: Date.now(),
          lt: 0,
          planeProgress: 0,
          dotsProgress: 0,
          fadeInProgress: 0,
          textProgress: 0,
          stepOffset: 0,
          textOffset: 0,
          markupOffset: 0,
          glitches: [],
          animLines: [],
          animNumbers: [],
          tabIsActive: true,
          planeIsDrawn: false,
          mousePower: 0,
          textPixelData: [],
          text: {},
          delta: 0,
          dlt: performance.now(),
          needRedraw: true
        };

        this.bindNodes();
        this.getDimensions();
        mouse.x = doc.width / 2;
        mouse.y = doc.height / 2;
        this.start();
      }
      start() {
        this.initEvents();
        this.canvasInit();
        this.loop();
        this.initCheckingInterval();
        this.splitText();
      }
      splitText() {
        ui.textNodes.forEach(el => {
          const value = el.innerText;
          el.innerHTML = value.split('').reduce((acc, cur) => {
            return acc + `<span class="letter">${cur}</span>`;
          }, '');
        });
      }
      animateText() {
        const callback = () => {
          ui.mouse.classList.add('active');
        };
        ui.textNodes.forEach((el, elIndex) => {
          el.classList.add('active');
          const letters = el.querySelectorAll('.letter');
          const length = Math.round(letters.length / 2) + 1;
          for (let i = 0; i < length; i++) {
            const [letter1, letter2] = [letters[i], letters[letters.length - i]];
            setTimeout(() => {
              if (letter1) letter1.classList.add('active');
              if (letter2) letter2.classList.add('active');
              if (i === length - 1 && elIndex === ui.textNodes.length - 1) callback();
            }, i * 100);
          }
        });
      }
      getDimensions() {
        doc.height = document.documentElement.clientHeight;
        doc.width = document.documentElement.clientWidth;
      }
      updatePlane() {

        const { width: w, height: h } = doc;

        const cell = Math.round(w / cfg.cell);

        const xPreSize = w / cell;
        plane.xCell = w / xPreSize % 2 !== 0 ? w / (w / xPreSize + 1) : xPreSize;

        const yPreSize = h / Math.round(cell * (h / w));
        plane.yCell = h / yPreSize % 2 !== 0 ? h / (h / yPreSize + 1) : yPreSize;

        plane.cells = [Math.round(w / plane.xCell), Math.round(h / plane.yCell)];
        plane.xCenter = Math.round(plane.cells[1] / 2);
        plane.yCenter = Math.round(plane.cells[0] / 2);
        plane.centerCoords = [plane.yCenter * plane.xCell, plane.xCenter * plane.yCell];

      }
      bindNodes() {
        for (const selector in ui) {
          ui[selector] = document.querySelectorAll(ui[selector]);
          if (ui[selector].length === 1) ui[selector] = ui[selector][0];
        }
      }
      canvasInit() {
        const font = '10px Montserrat';
        const lineCapAndJoin = 'round';
        const color = `rgba(255, 255, 255, 0.1)`;

        context.plane = ui.plane.getContext('2d');
        context.plane.lineCap = lineCapAndJoin;
        context.plane.lineJoin = lineCapAndJoin;
        context.plane.font = font;
        context.plane.fillStyle = color;
        context.plane.strokeStyle = color;

        context.main = ui.main.getContext('2d');
        context.main.lineCap = lineCapAndJoin;
        context.main.lineJoin = lineCapAndJoin;
        context.main.font = font;
        context.main.fillStyle = color;
        context.main.strokeStyle = color;

        this.getTextPixels();
      }
      initEvents() {

        window.addEventListener('resize', e => {
          this.getDimensions();
          this.resizeHandler(e);
        });
        document.addEventListener('mousemove', e => {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
          mouse.coords = {
            x: (mouse.x / doc.width - 0.5) / 0.5,
            y: (mouse.y / doc.height - 0.5) / 0.5 * -1
          };

        });
        document.addEventListener('mousedown', e => {
          mouse.down = {
            state: true,
            x: e.clientX,
            y: e.clientY
          };

        });
        document.addEventListener('mouseup', e => {
          mouse.down.state = false;
        });
        document.addEventListener('contextmenu', e => {
          e.preventDefault();
        });
        this.resizeHandler();

      }
      resizeHandler(e) {
        const state = this.state;
        state.area = doc.width * doc.height / 1000000;
        ui.main.height = doc.height;
        ui.main.width = doc.width;
        ui.plane.height = doc.height;
        ui.plane.width = doc.width;
        this.updatePlane();
        this.updateTextConfig();
        if (state.planeIsDrawn) this.getTextPixels();
        state.needRedraw = true;
      }
      updateTextConfig() {
        const state = this.state;
        state.text = {
          baseLine: 'top',
          font: '800 94px Montserrat',
          value: 'DENZEL'
        };

      }
      initCheckingInterval() {
        const state = this.state;
        setInterval(() => {
          state.tabIsActive = state.time <= state.lt ? false : true;
          state.lt = state.time;
          state.needRedraw = !state.tabIsActive;
        }, 100);
      }
      loop() {
        const loop = () => {
          const ctx = context.main;
          const state = this.state;
          state.time = Date.now();
          ctx.clearRect(0, 0, doc.width, doc.height);
          this.updateState();
          this.draw();
          if (state.needRedraw) state.needRedraw = false;
          this.raf = requestAnimationFrame(loop);
        };
        loop();
      }
      updateState() {
        const state = this.state;

        const now = performance.now();
        state.delta = now - state.dlt;
        state.dlt = now;

        const dt = state.delta;

        if (mouse.down.state) {
          state.mousePower += +0.001 * dt;
          if (state.mousePower >= 1) {
            state.mousePower = 1;
            ui.mouse.classList.remove('active');
          }
        } else {
          state.mousePower -= 0.001 * dt;
          if (state.mousePower <= 0) state.mousePower = 0;
        }

        const mp = tools.cellEasing(state.mousePower, 0, 1, 1);

        if (state.planeProgress >= 0.2) {
          state.dotsProgress += 0.00035 * dt;
          if (state.dotsProgress >= 1) state.dotsProgress = 1;
        }

        state.planeProgress += 0.00035 * dt;
        if (state.planeProgress >= 1) state.planeProgress = 1;

        if (state.planeIsDrawn) {

          state.fadeInProgress += 0.00015 * dt;
          if (state.fadeInProgress >= 1) state.fadeInProgress = 1;

          state.stepOffset += 0.002 * dt + mp * (0.0035 * dt);
          state.textOffset += 0.00005 * dt + mp * (0.002 * dt);
          state.markupOffset += 0.00015 * dt + mp * (0.00035 * dt);

          state.textProgress += 0.0005 * dt;
          if (state.textProgress >= 1) state.textProgress = 1;
        }
      }
      getTextPixels() {
        const ctx = context.main;
        const state = this.state;
        const { xCell, yCell } = plane;
        tools.drawPath(ctx, () => {
          ctx.fillStyle = 'white';
          ctx.textBaseline = state.text.baseLine;
          ctx.font = state.text.font;
          const text = state.text.value;
          const h = parseInt(ctx.font);
          const w = ctx.measureText(text).width;
          const x = doc.width / 2 - w / 2;
          const y = yCell * 2.75;
          ctx.fillText(text, x, y);
        });
        const imageData = ctx.getImageData(0, 0, doc.width, doc.height).data;
        state.textPixelData = [];
        const offset = 10;
        for (let h = 0; h < doc.height; h += offset) {
          for (let w = 0; w < doc.width; w += offset) {
            const pixel = imageData[(w + h * doc.width) * 4 - 1];
            if (pixel == 255) state.textPixelData.push({
              x: w,
              y: h,
              value: tools.random(0, 1, true)
            });

          }
        }
        ctx.clearRect(0, 0, doc.width, doc.height);
      }
      drawText() {

        const { yCell } = plane;
        const ctx = context.main;
        const state = this.state;
        const p = state.textOffset;
        const mp = tools.cellEasing(state.mousePower, 0, 1, 1);
        const length = state.textPixelData.length;

        tools.drawPath(ctx, () => {
          if (cfg.shadowBlur) {
            ctx.shadowColor = 'rgba(255,255,255,0.025)';
            ctx.shadowBlur = 30 * state.mousePower;
          }
          ctx.globalAlpha = state.fadeInProgress * 0.95;
          ctx.textBaseline = state.text.baseLine;
          ctx.fillStyle = cfg.bgColor;
          ctx.font = state.text.font;
          const text = state.text.value;
          const x = doc.width / 2 - ctx.measureText(text).width / 2;
          const y = yCell * 2.75;
          ctx.fillText(text, x, y);
        });

        for (let i = 0; i < state.textPixelData.length; i++) {
          const pixel = state.textPixelData[i];
          const { x, y, value } = pixel;
          const x2 = (3 + mp * 50) * Math.sin(p * i);
          const y2 = (10 + mp * 50) * Math.cos(p * i);
          const per = (1 - mp) * (i / length);
          tools.drawPath(ctx, () => {
            if (!per) return;
            ctx.globalAlpha = state.fadeInProgress;
            ctx.font = '8px Montserrat';

            ctx.fillStyle = `rgba(255,255,255,${per * 0.3})`;
            if (i % 2 === 0) ctx.fillText(value + '', x, y + y2 * -1);

            ctx.fillStyle = `rgba(255,255,255,${per})`;
            ctx.fillRect(x + x2, y, 5 * per * (1 - mp), 1);
            ctx.fillRect(x, y + y2, 1, 5 * per * (1 - mp));
          });
        }

      }
      draw() {

        const ctx = context.main;
        const state = this.state;

        const {
          xCell,
          yCell,
          xCenter,
          yCenter,
          cells } =
          plane;

        const cp = state.planeProgress;

        if (this.state.planeProgress >= 1 && !state.planeIsDrawn) {
          state.planeIsDrawn = true;
          this.startGeneratingGlitches();
          this.startGeneratingLines();
          this.startGeneratingNumbers();
          this.getTextPixels();
          this.animateText();
        }

        if (!state.planeIsDrawn || state.dotsProgress < 1 || state.planeIsDrawn && state.needRedraw) {
          this.drawPlane();
        }

        for (let i = 0; i < cells[0]; i++) {
          for (let i2 = 0; i2 < cells[1]; i2++) {

            const x = i * xCell;
            const y = i2 * yCell;

            if (state.planeIsDrawn) {
              this.drawMouseMoveInteraction({ i, i2, x, y });
              if (i2 === xCenter && i !== yCenter) {
                this.drawMarkupYAnimation({ i, i2, x, y, cp });
              }
              if (i2 !== xCenter && i === yCenter) {
                this.drawMarkupXAnimation({ i, i2, x, y, cp });
              }
            }

          }
        }

        if (state.planeIsDrawn) {
          this.drawGlitches();
          this.drawAnimLines();
          this.drawNumbersAnimation();
          this.drawText();
        }

      }
      startGeneratingNumbers() {
        const state = this.state;
        function generateItem() {
          const { cells, xCell, yCell } = plane;
          const mp = state.mousePower;
          const timeToNewItem = tools.random(
            1 + 50 * (1 - mp),
            5 + 100 * (1 - mp)) /
            state.area;
          const item = {
            p: 0,
            color: `rgba(255,255,255,${tools.random(0.01, 0.3)})`,
            blinks: Array(tools.random(0, 3, true)).fill(null).map(item => {
              return {
                at: tools.random(0, 1),
                dur: tools.random(0, 0.3)
              };

            }),
            pf: tools.random(0.00075, 0.01),
            x: tools.random(0, cells[0], true) * xCell,
            y: tools.random(0, cells[1], true) * yCell,
            value: tools.random(0, 1, true)
          };

          if (state.tabIsActive) state.animNumbers.push(item);
          setTimeout(generateItem, timeToNewItem);
        }
        generateItem();
      }
      drawNumbersAnimation() {
        const ctx = context.main;
        const state = this.state;
        const {
          yCell,
          xCell } =
          plane;
        state.animNumbers.forEach((item, i) => {
          item.p += item.pf * state.delta;
          let show = true;
          item.blinks.forEach(blink => {
            if (item.p >= blink.at && item.p <= blink.at + blink.dur) show = false;
          });
          if (!show) return;
          tools.drawPath(ctx, () => {
            if (cfg.shadowBlur) {
              ctx.shadowColor = 'white';
              ctx.shadowBlur = 10;
            }
            ctx.globalAlpha = state.fadeInProgress;
            ctx.textBaseline = 'top';
            ctx.font = '18px Montserrat';
            const th = parseInt(ctx.font) || 18;
            const tw = ctx.measureText(item.value + '').width;
            ctx.fillStyle = item.color;
            ctx.fillText(item.value + '', item.x + xCell / 2 - tw / 2, item.y + yCell / 2 - th / 2);
          });
          if (item.p >= 1) state.animNumbers.splice(i, 1);
        });
      }
      startGeneratingLines() {
        const state = this.state;
        function generateItem() {
          const { cells, xCell, yCell } = plane;
          const mp = state.mousePower;
          const timeToNewItem = tools.random(
            25 + 80 * (1 - mp),
            75 + 1200 * (1 - mp)) /
            state.area;
          const item = {
            p: 0,
            color: tools.random(0, 0.15),
            pf: tools.random(0.0005, 0.00125),
            x: tools.random(0, cells[0], true) * xCell,
            y: tools.random(0, cells[1], true) * yCell
          };

          item.coord = tools.random(0, 1, true) ? 'x' : 'y';
          item.length = tools.random(xCell * 2, state.area * xCell * 5);
          item.dir = tools.random(0, 1, true) ? 1 : -1;
          item.distance = item.length * tools.random(1, 2);
          if (state.tabIsActive) state.animLines.push(item);
          setTimeout(generateItem, timeToNewItem);
        }
        generateItem();
      }
      drawAnimLines() {
        const ctx = context.main;
        const state = this.state;
        state.animLines.forEach((line, i) => {

          line.p += line.pf * state.delta;
          const p = tools.easing(line.p, 0, 1, 1);

          const p1 = p / 0.5;
          const p2 = 1 - (p - 0.5) / 0.5;
          const color = `rgba(255,255,255,${0.1 + line.color * (p <= 0.5 ? p1 : p2)})`;

          const length = p <= 0.5 ? line.length * p1 : line.length * p2;
          const backwards = line.dir === -1;

          const isX = line.coord === 'x';
          const isY = line.coord === 'y';

          const x = !isX ? 0 : backwards ? -(length - line.distance * p) : -line.distance * p;
          const y = !isY ? 0 : backwards ? -(length - line.distance * p) : -line.distance * p;

          tools.drawPath(ctx, () => {
            ctx.globalAlpha = state.fadeInProgress;
            ctx.fillStyle = color;
            ctx.fillRect(
              line.x + x + (isX && p <= 0.5 ? (line.length - length) * line.dir : 0),
              line.y + y + (isY && p <= 0.5 ? (line.length - length) * line.dir : 0),
              isX ? length : 1,
              isY ? length : 1);

          });
          if (line.p >= 1) state.animLines.splice(i, 1);
        });
      }
      startGeneratingGlitches() {
        const state = this.state;
        function generateItem() {
          const { cells, xCell, yCell } = plane;
          const mp = state.mousePower;
          const timeToNewItem = tools.random(
            (5 + 100 * (1 - mp)) / state.area,
            (25 + 1200 * (1 - mp)) / state.area);

          const item = {
            p: 0,
            color: `rgba(255,255,255,${tools.random(0.01, 1)})`,
            blinks: Array(tools.random(0, 3, true)).fill(null).map(blink => {
              return {
                at: tools.random(0, 1),
                dur: tools.random(0, 0.3)
              };

            }),
            pf: tools.random(0.0015, 0.0035),
            x: tools.random(0, cells[0], true) * xCell,
            y: tools.random(0, cells[1], true) * yCell,
            width: xCell,
            height: yCell
          };

          if (state.tabIsActive) state.glitches.push(item);
          setTimeout(generateItem, timeToNewItem);
        }
        generateItem();
      }
      drawGlitches() {
        const ctx = context.main;
        const state = this.state;
        state.glitches.forEach((glitch, i) => {
          glitch.p += glitch.pf * state.delta;
          let show = true;
          glitch.blinks.forEach(blink => {
            if (glitch.p >= blink.at && glitch.p <= blink.at + blink.dur) show = false;
          });
          if (!show) return;
          tools.drawPath(ctx, () => {
            if (cfg.shadowBlur) {
              ctx.shadowColor = 'white';
              ctx.shadowBlur = 30;
            }
            ctx.globalAlpha = state.fadeInProgress;
            ctx.fillStyle = glitch.color;
            ctx.fillRect(glitch.x, glitch.y, glitch.width, glitch.height);
          });
          if (glitch.p >= 1) state.glitches.splice(i, 1);
        });
      }
      drawMouseMoveInteraction(props) {
        const ctx = context.main;
        const state = this.state;
        const fp = state.fadeInProgress;
        const sp = state.stepOffset;
        const mp = state.mousePower;
        const {
          xCenter,
          yCenter } =
          plane;
        const { i, i2, x, y } = props;
        const position = [Math.abs(i2 - xCenter), Math.abs(i - yCenter)];
        const mouseRange = (200 + 50 * mp) * (i * i2 % 2) * Math.sin(position[0] - position[1]);
        if (mouseRange <= 100) return;

        const vector = tools.getVectorLength([x, y], [mouse.x, mouse.y]);

        if (vector <= mouseRange) {

          const percent = (1 - vector / mouseRange) * fp;
          const spinRadius = 50 * (1 - percent);
          const xOffset = Math.sin(sp + i) * spinRadius * (Math.PI * 2 / 4) * ((i + i2) % 4 == 0 ? -1 : 1);
          const yOffset = Math.cos(sp + i2) * spinRadius * (Math.PI * 2 / 4);

          const sx = x + xOffset;
          const sy = y + yOffset;

          const radius = 25 * (1 - percent);
          const lineWidth = 3 + 10 * percent;


          const vector2 = tools.getVectorLength([sx, sy], [mouse.x, mouse.y]);
          const p2 = 1 - vector2 / (mouseRange + spinRadius * 2);

          const color = `rgba(255,255,255,${0.3 * percent})`;
          const color2 = `rgba(255,255,255,${0.7 * p2 * percent})`;

          tools.drawPath(ctx, () => {
            ctx.strokeStyle = color2;
            ctx.moveTo(sx, sy);
            ctx.lineTo(mouse.x, mouse.y);
            ctx.stroke();
          });
          tools.drawPath(ctx, () => {
            ctx.strokeStyle = color2;
            ctx.moveTo(x, y);
            ctx.lineTo(sx, sy);
            ctx.stroke();
          });
          tools.drawPath(ctx, () => {
            ctx.fillStyle = color;
            ctx.arc(x, y, 1, 0, 2 * Math.PI);
            ctx.fill();
          });
          tools.drawPath(ctx, () => {
            ctx.strokeStyle = `rgba(255,255,255,${0.5 * percent})`;
            ctx.lineWidth = 1 + 2 * (1 - percent);
            ctx.arc(x, y, 3 + 10 * (1 - percent), 0, 2 * Math.PI);
            ctx.stroke();
          });
          tools.drawPath(ctx, () => {
            ctx.fillStyle = `rgba(255,255,255,${percent})`;
            ctx.arc(sx, sy, 1, 0, 2 * Math.PI);
            ctx.fill();
          });
          tools.drawPath(ctx, () => {
            if (cfg.shadowBlur) {
              ctx.shadowColor = 'white';
              ctx.shadowBlur = radius;
            }
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = `rgba(255,255,255,${0.75 * percent})`;
            ctx.arc(sx, sy, radius, 0, 2 * Math.PI);
            ctx.stroke();
          });
        }

      }
      drawPlaneDotsAnimation(props) {
        const ctx = context.plane;
        const { dp, i, i2, x, y } = props;
        const {
          xCenter,
          yCenter } =
          plane;
        const position = [Math.abs(i2 - xCenter), Math.abs(i - yCenter)];
        const index = position[0] * position[1];
        const maxIndex = xCenter * yCenter;
        const percent = 1 / maxIndex;
        const point = percent * index;
        let f = dp * (dp / point);
        if (f >= 1) f = 1;
        const mf = f >= 0.5 ? (1 - f) / 0.5 : f / 0.5;
        const size = 3;
        if (!mf) return;
        tools.drawPath(ctx, () => {
          ctx.fillStyle = `rgba(255,255,255,${mf * 0.15})`;
          ctx.fillRect(x - 1, y - 1, size, size);
        });
      }
      drawPlaneCenterLines(props) {
        const { p } = props;
        const ctx = context.plane;
        const {
          centerCoords } =
          plane;
        tools.drawPath(ctx, () => {
          ctx.fillStyle = `rgba(255,255,255,${0.2 + (1 - p) * 1})`;
          ctx.fillRect(centerCoords[0], 0 + doc.height / 2 * (1 - p), 1, doc.height * p);
          ctx.fillRect(0 + doc.width / 2 * (1 - p), centerCoords[1], doc.width * p, 1);
        });
      }
      drawYLines(props) {
        const { i, cp, p, x } = props;
        const ctx = context.plane;
        const {
          yCenter } =
          plane;
        const percent = 1 / yCenter;
        const pos = Math.abs(i - yCenter);
        const point = percent * pos;
        let f = cp * (cp / point);
        if (f >= 1) f = 1;
        const ef = tools.cellEasing(f, 0, 1, 1);
        if (i) {
          tools.drawPath(ctx, () => {
            ctx.fillStyle = `rgba(255,255,255,${0.05 + (1 - p) * 0.35})`;
            ctx.fillRect(x, 0 + doc.height / 2 * (1 - ef), 1, doc.height * ef);
          });
        }
      }
      drawYMarkup(props) {
        const ctx = context.plane;
        const state = this.state;
        let { i, p, cp, x, y } = props;
        const {
          yCenter } =
          plane;
        const percent = 1 / yCenter;
        const pos = Math.abs(i - yCenter);
        const point = percent * pos;
        const conds = [p >= point, p <= point + percent];
        let f = cp * (cp / point);
        if (f >= 1) f = 1;
        const f2 = conds[0] && conds[1] ? (p - point) / percent : conds[0] ? 1 : 0;

        const text = i - yCenter + '';
        ctx.fillStyle = `rgba(255,255,255,${0.1 + (1 - f) * 0.75})`;
        const textCoords = [x - ctx.measureText(text).width / 2, y + cfg.sectionWidth / 2 + cfg.numberOffset];
        tools.drawPath(ctx, () => {
          const o = (1 - f2) * 50;
          ctx.globalAlpha = f2;
          ctx.fillRect(x, y - cfg.sectionWidth / 2 + o, cfg.sectionHeight, cfg.sectionWidth);
        });
        tools.drawPath(ctx, () => {
          ctx.globalAlpha = f2;
          ctx.textBaseline = 'top';
          ctx.fillText(
            text,
            textCoords[0],
            textCoords[1] + (1 - f2) * -20);

        });
      }
      drawXLines(props) {
        const ctx = context.plane;
        const { i2, cp, p, y } = props;
        const {
          xCenter } =
          plane;
        const percent = 1 / xCenter;
        const pos = Math.abs(i2 - xCenter);
        const point = percent * pos;
        let f = cp * (cp / point);
        if (f >= 1) f = 1;
        const ef = tools.cellEasing(f, 0, 1, 1);
        if (i2) {
          tools.drawPath(ctx, () => {
            ctx.fillStyle = `rgba(255,255,255,${0.05 + (1 - p) * 0.35})`;
            ctx.fillRect(0 + doc.width / 2 * (1 - ef), y, doc.width * ef, 1);
          });
        }
      }
      drawXMarkup(props) {
        const ctx = context.plane;
        const state = this.state;
        let { i2, p, cp, x, y } = props;
        const {
          xCenter } =
          plane;

        const percent = 1 / xCenter;
        const pos = Math.abs(i2 - xCenter);
        const point = percent * pos;
        const conds = [p >= point, p <= point + percent];
        let f = cp * (cp / point);
        if (f >= 1) f = 1;
        let f2 = conds[0] && conds[1] ? (p - point) / percent : conds[0] ? 1 : 0;

        ctx.fillStyle = `rgba(255,255,255,${0.1 + (1 - f) * 0.75})`;
        tools.drawPath(ctx, () => {
          const o = (1 - f2) * 50;
          ctx.globalAlpha = f2;
          ctx.fillRect(x - cfg.sectionWidth / 2 + o, y, cfg.sectionWidth, cfg.sectionHeight);
        });
        tools.drawPath(ctx, () => {
          ctx.globalAlpha = f2;
          ctx.textBaseline = 'middle';
          const textCoords = [x + cfg.sectionWidth / 2 + cfg.numberOffset, y + cfg.sectionHeight / 2];
          ctx.fillText(
            xCenter - i2 + '',
            textCoords[0] + (1 - f2) * -20,
            textCoords[1]);

        });
      }
      drawPlane() {

        const state = this.state;
        const ctx = context.plane;

        ctx.clearRect(0, 0, doc.width, doc.height);

        const {
          xCell,
          yCell,
          xCenter,
          yCenter,
          cells } =
          plane;

        const p = tools.easing(state.planeProgress, 0, 1, 1);
        const cp = state.planeProgress;
        const dp = state.dotsProgress;

        this.drawPlaneCenterLines({ p });

        for (let i = 0; i < cells[0]; i++) {
          for (let i2 = 0; i2 < cells[1]; i2++) {

            const x = i * xCell;
            const y = i2 * yCell;

            if (i !== yCenter && i2 !== xCenter) {
              this.drawPlaneDotsAnimation({ dp, i, i2, x, y });
            }
            if (i2 === xCenter && i !== yCenter) {
              this.drawYLines({ i, i2, p, cp, x, y });
              this.drawYMarkup({ i, p, cp, x, y });
            }
            if (i2 !== xCenter && i === yCenter) {
              this.drawXLines({ i, i2, p, cp, x, y });
              this.drawXMarkup({ i2, p, cp, x, y });
            }
          }
        }

      }
      drawMarkupYAnimation(props) {

        const ctx = context.main;
        const {
          yCenter } =
          plane;
        const { i, x, y } = props;

        const state = this.state;
        const spSin = Math.sin(state.markupOffset);
        const sp = spSin >= 0 ? tools.cellEasing(Math.abs(spSin), 0, 1, 1) : 0;

        const percent = 1 / yCenter;
        const pos = Math.abs(i - yCenter);
        const point = percent * pos;

        const f = sp >= point && sp <= point + percent ? (sp - point) / percent : 0;
        if (!f) return;

        const text = i - yCenter + '';

        ctx.fillStyle = `rgba(255,255,255,${0.1 + (1 - f) * 0.75})`;
        const textCoords = [x - ctx.measureText(text).width / 2, y + cfg.sectionWidth / 2 + cfg.numberOffset];
        tools.drawPath(ctx, () => {
          ctx.fillStyle = `rgba(255,255,255,${f * 0.5})`;
          ctx.fillRect(x, y - cfg.sectionWidth / 2, cfg.sectionHeight, cfg.sectionWidth);
        });
        tools.drawPath(ctx, () => {
          if (cfg.shadowBlur) {
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'white';
          }
          ctx.fillStyle = `rgba(255,255,255,${f * 0.35})`;
          ctx.textBaseline = 'top';
          ctx.fillText(
            text,
            textCoords[0],
            textCoords[1]);

        });
      }
      drawMarkupXAnimation(props) {

        const ctx = context.main;
        const state = this.state;
        let { i2, x, y } = props;
        const spSin = Math.sin(state.markupOffset);
        const sp = spSin <= 0 ? tools.cellEasing(Math.abs(spSin), 0, 1, 1) : 0;
        const {
          xCenter } =
          plane;

        const percent = 1 / xCenter;
        const pos = Math.abs(i2 - xCenter);
        const point = percent * pos;

        const f = sp >= point && sp <= point + percent ? (sp - point) / percent : 0;
        if (!f) return;

        tools.drawPath(ctx, () => {
          ctx.fillStyle = `rgba(255,255,255,${f * 0.5})`;
          ctx.fillRect(x - cfg.sectionWidth / 2, y, cfg.sectionWidth, cfg.sectionHeight);
        });

        tools.drawPath(ctx, () => {
          if (cfg.shadowBlur) {
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'white';
          }
          ctx.fillStyle = `rgba(255,255,255,${f * 0.3})`;
          ctx.textBaseline = 'middle';
          const textCoords = [x + cfg.sectionWidth / 2 + cfg.numberOffset, y + cfg.sectionHeight / 2];
          ctx.fillText(
            xCenter - i2 + '',
            textCoords[0],
            textCoords[1]);

        });

      }
    }


    window.addEventListener('load', () => {
      window.app = new App();
    }); 
  </script>
  <script>
    const audio = new Audio('./assets/mp3/me.mp3');
    audio.volume = 0.1;
    audio.autoplay = false;

    $('.trigger').click(function () {
      if (audio.paused == false) {
        audio.pause();
        $('.fa-play').show();
        $('.fa-pause').hide();
        $('.music-card').removeClass('playing');
      } else {
        audio.play();
        $('.fa-pause').show();
        $('.fa-play').hide();
        $('.music-card').addClass('playing');
      }
    }); 
  </script>
  <script>
    class TextScramble {
      constructor(el) {
        this.el = el
        this.chars = '!<>-_\\/[]{}â€”=+*^?#________'
        this.update = this.update.bind(this)
      }
      setText(newText) {
        const oldText = this.el.innerText
        const length = Math.max(oldText.length, newText.length)
        const promise = new Promise((resolve) => this.resolve = resolve)
        this.queue = []
        for (let i = 0; i < length; i++) {
          const from = oldText[i] || ''
          const to = newText[i] || ''
          const start = Math.floor(Math.random() * 80)
          const end = start + Math.floor(Math.random() * 80)
          this.queue.push({ from, to, start, end })
        }
        cancelAnimationFrame(this.frameRequest)
        this.frame = 0
        this.update()
        return promise
      }
      update() {
        let output = ''
        let complete = 0
        for (let i = 0, n = this.queue.length; i < n; i++) {
          let { from, to, start, end, char } = this.queue[i]
          if (this.frame >= end) {
            complete++
            output += to
          } else if (this.frame >= start) {
            if (!char || Math.random() < 0.28) {
              char = this.randomChar()
              this.queue[i].char = char
            }
            output += `<span class="dud">${char}</span>`
          } else {
            output += from
          }
        }
        this.el.innerHTML = output
        if (complete === this.queue.length) {
          this.resolve()
        } else {
          this.frameRequest = requestAnimationFrame(this.update)
          this.frame++
        }
      }
      randomChar() {
        return this.chars[Math.floor(Math.random() * this.chars.length)]
      }
    }

    const phrases = [
      'Hey,',
      'I am SWE with 8 years of experience specializing in',
      'Distributed systems',
      'Algorithms',
      'Trading',
      'Crypto',
      'Zero knowledge proof'
    ]

    const el = document.querySelector('.text')
    const fx = new TextScramble(el)

    let counter = 0
    const next = () => {
      fx.setText(phrases[counter]).then(() => {
        setTimeout(next, 2000)
      })
      counter = (counter + 1) % phrases.length
    }

    next()

  </script>
  <script>

    "use strict";
    console.clear();
    console.log('You should not be here =)')
    class Stage {
      constructor() {
        this.render = function () {
          this.renderer.render(this.scene, this.camera);
        };
        this.add = function (elem) {
          this.scene.add(elem);
        };
        this.remove = function (elem) {
          this.scene.remove(elem);
        };
        this.container = document.getElementById('game');
        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor('#080808', 1);
        this.container.appendChild(this.renderer.domElement);
        this.scene = new THREE.Scene();
        let aspect = window.innerWidth / window.innerHeight;
        let d = 20;
        this.camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, -100, 1000);
        this.camera.position.x = 2;
        this.camera.position.y = 2;
        this.camera.position.z = 2;
        this.camera.lookAt(new THREE.Vector3(0, 0, 0));
        this.light = new THREE.DirectionalLight(0xffffff, 0.5);
        this.light.position.set(0, 499, 0);
        this.scene.add(this.light);
        this.softLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(this.softLight);
        window.addEventListener('resize', () => this.onResize());
        this.onResize();
      }
      setCamera(y, speed = 0.3) {
        TweenLite.to(this.camera.position, speed, { y: y + 4, ease: Power1.easeInOut });
        TweenLite.to(this.camera.lookAt, speed, { y: y, ease: Power1.easeInOut });
      }
      onResize() {
        let viewSize = 30;
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.left = window.innerWidth / -viewSize;
        this.camera.right = window.innerWidth / viewSize;
        this.camera.top = window.innerHeight / viewSize;
        this.camera.bottom = window.innerHeight / -viewSize;
        this.camera.updateProjectionMatrix();
      }
    }
    class Block {
      constructor(block) {
        this.STATES = { ACTIVE: 'active', STOPPED: 'stopped', MISSED: 'missed' };
        this.MOVE_AMOUNT = 12;
        this.dimension = { width: 0, height: 0, depth: 0 };
        this.position = { x: 0, y: 0, z: 0 };
        this.targetBlock = block;
        this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
        this.workingPlane = this.index % 2 ? 'x' : 'z';
        this.workingDimension = this.index % 2 ? 'width' : 'depth';
        this.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;
        this.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;
        this.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;
        this.position.x = this.targetBlock ? this.targetBlock.position.x : 0;
        this.position.y = this.dimension.height * this.index;
        this.position.z = this.targetBlock ? this.targetBlock.position.z : 0;
        this.colorOffset = this.targetBlock ? this.targetBlock.colorOffset : Math.round(Math.random() * 100);
        if (!this.targetBlock) {
          this.color = 0x333344;
        } else {
          let offset = this.index + this.colorOffset;
          const r = Math.sin(0.3 * offset) * 55 + 200;
          const g = Math.sin(0.3 * offset + 2) * 55 + 200;
          const b = Math.sin(0.3 * offset + 4) * 55 + 200;
          this.color = new THREE.Color(r / 255, g / 255, b / 255);
        }

        this.state = this.index > 1 ? this.STATES.ACTIVE : this.STATES.STOPPED;

        this.speed = -0.1 - (this.index * 0.005);
        if (this.speed < -4)
          this.speed = -4;
        this.direction = this.speed;

        let geometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
        geometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width / 2, this.dimension.height / 2, this.dimension.depth / 2));
        this.material = new THREE.MeshToonMaterial({ color: this.color, shading: THREE.FlatShading });
        this.mesh = new THREE.Mesh(geometry, this.material);
        this.mesh.position.set(this.position.x, this.position.y + (this.state == this.STATES.ACTIVE ? 0 : 0), this.position.z);
        if (this.state == this.STATES.ACTIVE) {
          this.position[this.workingPlane] = Math.random() > 0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;
        }
      }
      reverseDirection() {
        this.direction = this.direction > 0 ? this.speed : Math.abs(this.speed);
      }
      place() {
        this.state = this.STATES.STOPPED;
        let overlap = this.targetBlock.dimension[this.workingDimension] - Math.abs(this.position[this.workingPlane] - this.targetBlock.position[this.workingPlane]);
        let blocksToReturn = {
          plane: this.workingPlane,
          direction: this.direction
        };
        if (this.dimension[this.workingDimension] - overlap < 0.3) {
          overlap = this.dimension[this.workingDimension];
          blocksToReturn.bonus = true;
          this.position.x = this.targetBlock.position.x;
          this.position.z = this.targetBlock.position.z;
          this.dimension.width = this.targetBlock.dimension.width;
          this.dimension.depth = this.targetBlock.dimension.depth;
        }
        if (overlap > 0) {
          let choppedDimensions = { width: this.dimension.width, height: this.dimension.height, depth: this.dimension.depth };
          choppedDimensions[this.workingDimension] -= overlap;
          this.dimension[this.workingDimension] = overlap;
          let placedGeometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
          placedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width / 2, this.dimension.height / 2, this.dimension.depth / 2));
          let placedMesh = new THREE.Mesh(placedGeometry, this.material);
          let choppedGeometry = new THREE.BoxGeometry(choppedDimensions.width, choppedDimensions.height, choppedDimensions.depth);
          choppedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(choppedDimensions.width / 2, choppedDimensions.height / 2, choppedDimensions.depth / 2));
          let choppedMesh = new THREE.Mesh(choppedGeometry, this.material);
          let choppedPosition = {
            x: this.position.x,
            y: this.position.y,
            z: this.position.z
          };
          if (this.position[this.workingPlane] < this.targetBlock.position[this.workingPlane]) {
            this.position[this.workingPlane] = this.targetBlock.position[this.workingPlane];
          } else {
            choppedPosition[this.workingPlane] += overlap;
          }
          placedMesh.position.set(this.position.x, this.position.y, this.position.z);
          choppedMesh.position.set(choppedPosition.x, choppedPosition.y, choppedPosition.z);
          blocksToReturn.placed = placedMesh;
          if (!blocksToReturn.bonus)
            blocksToReturn.chopped = choppedMesh;
        } else {
          this.state = this.STATES.MISSED;
        }
        this.dimension[this.workingDimension] = overlap;
        return blocksToReturn;
      }
      tick() {
        if (this.state == this.STATES.ACTIVE) {
          let value = this.position[this.workingPlane];
          if (value > this.MOVE_AMOUNT || value < -this.MOVE_AMOUNT)
            this.reverseDirection();
          this.position[this.workingPlane] += this.direction;
          this.mesh.position[this.workingPlane] = this.position[this.workingPlane];
        }
      }
    }
    class Game {
      constructor() {
        this.STATES = {
          'LOADING': 'loading',
          'PLAYING': 'playing',
          'READY': 'ready',
          'ENDED': 'ended',
          'RESETTING': 'resetting'
        };
        this.blocks = [];
        this.state = this.STATES.LOADING;
        this.stage = new Stage();
        this.mainContainer = document.getElementById('container');
        this.scoreContainer = document.getElementById('score');
        this.startButton = document.getElementById('start-button');
        this.instructions = document.getElementById('instructions');
        this.scoreContainer.innerHTML = '0';
        this.newBlocks = new THREE.Group();
        this.placedBlocks = new THREE.Group();
        this.choppedBlocks = new THREE.Group();
        this.stage.add(this.newBlocks);
        this.stage.add(this.placedBlocks);
        this.stage.add(this.choppedBlocks);
        this.addBlock();
        this.tick();
        this.updateState(this.STATES.READY);
        document.addEventListener('keydown', e => {
          if (e.keyCode == 32)
            this.onAction();
        });
        document.addEventListener('click', e => {
          this.onAction();
        });
        document.addEventListener('touchstart', e => {
          e.preventDefault();

        });
      }
      updateState(newState) {
        for (let key in this.STATES)
          this.mainContainer.classList.remove(this.STATES[key]);
        this.mainContainer.classList.add(newState);
        this.state = newState;
      }
      onAction() {
        switch (this.state) {
          case this.STATES.READY:
            this.startGame();
            break;
          case this.STATES.PLAYING:
            this.placeBlock();
            break;
          case this.STATES.ENDED:
            this.restartGame();
            break;
        }
      }
      startGame() {
        if (this.state != this.STATES.PLAYING) {
          this.scoreContainer.innerHTML = '0';
          this.updateState(this.STATES.PLAYING);
          this.addBlock();
        }
      }
      restartGame() {
        this.updateState(this.STATES.RESETTING);
        let oldBlocks = this.placedBlocks.children;
        let removeSpeed = 0.2;
        let delayAmount = 0.02;
        for (let i = 0; i < oldBlocks.length; i++) {
          TweenLite.to(oldBlocks[i].scale, removeSpeed, { x: 0, y: 0, z: 0, delay: (oldBlocks.length - i) * delayAmount, ease: Power1.easeIn, onComplete: () => this.placedBlocks.remove(oldBlocks[i]) });
          TweenLite.to(oldBlocks[i].rotation, removeSpeed, { y: 0.5, delay: (oldBlocks.length - i) * delayAmount, ease: Power1.easeIn });
        }
        let cameraMoveSpeed = removeSpeed * 2 + (oldBlocks.length * delayAmount);
        this.stage.setCamera(2, cameraMoveSpeed);
        let countdown = { value: this.blocks.length - 1 };
        TweenLite.to(countdown, cameraMoveSpeed, { value: 0, onUpdate: () => { this.scoreContainer.innerHTML = String(Math.round(countdown.value)); } });
        this.blocks = this.blocks.slice(0, 1);
        setTimeout(() => {
          this.startGame();
        }, cameraMoveSpeed * 1000);
      }
      placeBlock() {
        let currentBlock = this.blocks[this.blocks.length - 1];
        let newBlocks = currentBlock.place();
        this.newBlocks.remove(currentBlock.mesh);
        if (newBlocks.placed)
          this.placedBlocks.add(newBlocks.placed);
        if (newBlocks.chopped) {
          this.choppedBlocks.add(newBlocks.chopped);
          let positionParams = { y: '-=30', ease: Power1.easeIn, onComplete: () => this.choppedBlocks.remove(newBlocks.chopped) };
          let rotateRandomness = 10;
          let rotationParams = {
            delay: 0.05,
            x: newBlocks.plane == 'z' ? ((Math.random() * rotateRandomness) - (rotateRandomness / 2)) : 0.1,
            z: newBlocks.plane == 'x' ? ((Math.random() * rotateRandomness) - (rotateRandomness / 2)) : 0.1,
            y: Math.random() * 0.1,
          };
          if (newBlocks.chopped.position[newBlocks.plane] > newBlocks.placed.position[newBlocks.plane]) {
            positionParams[newBlocks.plane] = '+=' + (40 * Math.abs(newBlocks.direction));
          } else {
            positionParams[newBlocks.plane] = '-=' + (40 * Math.abs(newBlocks.direction));
          }
          TweenLite.to(newBlocks.chopped.position, 1, positionParams);
          TweenLite.to(newBlocks.chopped.rotation, 1, rotationParams);
        }
        this.addBlock();
      }
      addBlock() {
        let lastBlock = this.blocks[this.blocks.length - 1];
        if (lastBlock && lastBlock.state == lastBlock.STATES.MISSED) {
          return this.endGame();
        }
        this.scoreContainer.innerHTML = String(this.blocks.length - 1);
        let newKidOnTheBlock = new Block(lastBlock);
        this.newBlocks.add(newKidOnTheBlock.mesh);
        this.blocks.push(newKidOnTheBlock);
        this.stage.setCamera(this.blocks.length * 2);
        if (this.blocks.length >= 5)
          this.instructions.classList.add('hide');
      }
      endGame() {
        this.updateState(this.STATES.ENDED);
      }
      tick() {
        this.blocks[this.blocks.length - 1].tick();
        this.stage.render();
        requestAnimationFrame(() => { this.tick(); });
      }
    }
    let game = new Game();
  </script>

  <script>
    const profilLogo = document.querySelectorAll(".profil-logo");
    const roleAdd = document.querySelectorAll(".role-add");
    const input = document.querySelectorAll(".message input");

    const randomHexColor = () => {
      return "#" + Math.floor(Math.random() * 16777215).toString(16);
    };

    const ramdomWord = () => {
      const words = [
        "Awesome",
        "Cool",
        "Great",
        "Nice",
        "Super",
        "Supernice",
        "Superior",
        "Wonderful",
        "Amazing",
        "Fantastic",
        "Fabulous",
        "Incredible",
        "Marvelous",
        "Spectacular",
        "Stupendous",
        "Terrific",
        "Astounding",
      ];
      return words[Math.floor(Math.random() * words.length)];
    };

    const addRole = (card) => {
      const role = document.createElement("div");
      const roleColor = document.createElement("div");
      const roleText = document.createElement("p");
      role.classList.add("role");
      roleColor.classList.add("role-color");
      roleColor.style.backgroundColor = randomHexColor();
      roleText.innerText = ramdomWord();
      role.append(roleColor, roleText);
      card.parentElement.append(role, card);
      removeRole();
    };

    const removeRole = () => {
      const roles = document.querySelectorAll(".role-color");
      roles.forEach((role) => {
        role.addEventListener("click", (e) => {
          e.target.parentElement.remove();
        });
      });
    };

    const toggleModal = () => {
      modal.classList.toggle("active");
    };

    profilLogo.forEach((logo) => {
      logo.addEventListener("click", toggleModal);
    });

    roleAdd.forEach((add) => {
      add.addEventListener("click", () => {
        addRole(add);
      });
    });

    removeRole();

    $(function () {
      $('#content').keypress(function (e) {
        if (e.which === 13) {
          e.preventDefault();

          const url = "";
          const content = $("#content").val();
          const username = "Denzel Website Messege";
          const avatar_url = $("#avatar_url").val();

          $.post(url, { "content": content, "username": username, "avatar_url": avatar_url })
            .done(function () {
              $('#message-status').fadeIn().delay(2000).fadeOut();
              $("#content").val("");
            });
        }
      });
    });

  </script>
</body>

</html>